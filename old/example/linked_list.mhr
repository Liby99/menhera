import { * from maybe }

type linked_list<T> { Tail, Node(T, linked_list<T>) }

module {

    /* Create a new linked_list */
    new = () : linked_list<T> => Tail,
    
    /* Get the i_th element of a linked list */
    get = (ls : linked_list<T>, i : int) : maybe<T> => match (ls) {
        Tail => None,
        Node(e, r) => if i == 0 then Some(e) else get(r, i - 1)
    },
    
    /* Pop an element out of the linked_list */
    pop = (ls : linked_list<T>) : maybe<linked_list<T>> => match (ls) {
        Tail => None,
        Node(_, r) => Some(r)
    },
    
    /* Get the first element of the linked_list */
    peek = (ls : linked_list<T>) : maybe<T> => get(ls, 0),
    
    /* Push an element to the front of the linked_list */
    push = (ls : linked_list<T>, e : T) : linked_list<T> => Node(e, ls),
    
    /* Get the length of the linked_list */
    length = (ls : linked_list<T>) : int => match (ls) {
        Tail => 0,
        Node(_, r) => 1 + length(r)
    },
    
    /* Operator # getting the length of the linked_list */
    `#` = length,
    
    /* Concatenate two linked_lists */
    concat = (l1 : linked_list<T>, l2 : linked_list<T>) : linked_list<T> => match (l2) {
        Tail => l1,
        Node(e, r) => Node(e, concat(l1, r))
    },
    
    /* Operator + concatenating two linked_lists */
    `+` = concat,
    
    /* fold_left on linked_list */
    fold_left = (f : (U, T) => U, b : U, ls : linked_list<T>) : U => match (ls) {
        Tail => b,
        Node(t, r) => fold_left(f, f(b, t), r)
    },
    
    /* map on linked_list */
    map = (f : (T) => U, ls : linked_list<T>) : linked_list<U> =>
        fold_left((b, x) => push(b, f(x)), Tail, ls),
        
    /* filter on linked_list */
    filter = (f : (T) => bool, ls : linked_list<T>) : linked_list<T> =>
        fold_left((b, x) => f(x) ? push(b, x) : b, Tail, ls),
    
    /* to string on linked_list */
    `$` = (ls : linked_list<T>) : string =>
        let m = match (ls) {
            Tail => "",
            Node(e, Tail) => $e,
            Node(e, r) => $e + ", " + $r
        } in "[" + m + "]"
}
